import type { RowNode } from '../entities/rowNode';
import type { SortOption } from '../interfaces/iSortOption';
import type { RowNodeSorter } from '../sort/rowNodeSorter';
import type { ChangedPath } from '../utils/changedPath';
import type { ChangedRowNodes } from './changedRowNodes';
/**
 * Performs an incremental (delta) sort that avoids re-sorting unchanged rows.
 *
 * Algorithm outline:
 * 1. Handle edge cases: empty input or single element - return early
 * 2. Fall back to full sort if no previous sorted result or too few rows
 * 3. Classify rows as "touched" (updated, added, or in changed path) vs "untouched"
 * 4. If no rows are touched, return previous sorted array (filtering removed nodes if needed)
 * 5. Sort only the touched rows using a stable sort with original index as tie-breaker
 * 6. If all rows are touched, return the sorted touched rows directly
 * 7. Merge the sorted touched rows with untouched rows from previous sort order
 *    using a two-pointer merge algorithm (similar to merge sort's merge step)
 *
 * Time complexity: O(t log t + n) where t = touched rows, n = total rows
 * This is faster than full sort O(n log n) when t << n
 */
export declare const doDeltaSort: (rowNodeSorter: RowNodeSorter, rowNode: RowNode, changedRowNodes: ChangedRowNodes, changedPath: ChangedPath, sortOptions: SortOption[]) => RowNode[];
